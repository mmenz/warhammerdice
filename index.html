<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warhammer Dice Roller</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
        }

        .container {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 2rem;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 100%;
        }

        h1 {
            color: #f39c12;
            margin-bottom: 2rem;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .input-section {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            justify-content: center;
            align-items: center;
            margin-bottom: 2rem;
        }

        .input-row {
            display: flex;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .reroll-section {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-self: flex-start;
            margin-top: 1.5rem;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .input-group label {
            font-weight: bold;
            color: #ecf0f1;
        }

        .input-group input {
            padding: 0.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
            color: #2c3e50;
        }

        .value-selector {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
            justify-content: center;
            margin-top: 0.5rem;
        }

        .value-row {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        .value-square {
            width: 40px;
            height: 40px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            color: #ecf0f1;
        }

        .value-square:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .value-square.selected {
            background: #f39c12;
            border-color: #f39c12;
            color: white;
        }

        .numeric-selector {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .numeric-display {
            width: 80px;
            height: 50px;
            border: 3px solid #ecf0f1;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.9);
            color: #2c3e50;
            font-size: 2rem;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }

        .button-column {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .numeric-button {
            width: 40px;
            height: 40px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #ecf0f1;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
        }

        .numeric-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .numeric-button:active {
            transform: scale(0.95);
        }

        .checkbox-container {
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox-container input[type="checkbox"],
        .checkbox-container input[type="radio"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-container label {
            font-size: 1rem;
            color: #ecf0f1;
            cursor: pointer;
        }

        .input-group {
            position: relative;
        }

        .secondary-selector {
            display: flex;
            gap: 0.3rem;
            justify-content: center;
            margin-top: 0.5rem;
        }

        .secondary-square {
            width: 25px;
            height: 25px;
            border: 1px solid #ecf0f1;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            color: #ecf0f1;
        }

        .secondary-square:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .secondary-square.selected {
            background: #e74c3c;
            border-color: #e74c3c;
            color: white;
        }

        .roll-button {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 1rem;
        }

        .roll-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .roll-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .phase-indicator {
            margin: 1rem 0;
            font-size: 1.5rem;
            font-weight: bold;
            color: #f39c12;
            min-height: 2rem;
        }

        .dice-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin: 2rem 0;
            min-height: 200px;
        }

        .dice-wrapper {
            perspective: 1000px;
            position: relative;
        }

        .dice {
            width: 60px;
            height: 60px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s ease-out;
        }

        .dice.rolling {
            animation: roll 1s ease-in-out;
        }

        .dice.failed_hit {
            opacity: 0.3;
            transition: opacity 0.5s ease, filter 0.5s ease;
        }

        .dice.failed_hit .face {
            background: rgba(255, 0, 0, 1.0);
        }

        .dice.failed_wound {
            opacity: 0.3;
            transition: opacity 0.5s ease, filter 0.5s ease;
        }

        .dice.failed_wound .face {
            background: rgba(0, 255, 0, 1.0);
        }

        @keyframes roll {
            0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
            25% { transform: rotateX(360deg) rotateY(180deg) rotateZ(90deg); }
            50% { transform: rotateX(720deg) rotateY(360deg) rotateZ(180deg); }
            75% { transform: rotateX(1080deg) rotateY(540deg) rotateZ(270deg); }
            100% { transform: rotateX(1440deg) rotateY(720deg) rotateZ(360deg); }
        }

        .face {
            position: absolute;
            width: 60px;
            height: 60px;
            background: white;
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.1);
        }

        .dot {
            width: 8px;
            height: 8px;
            background: #333;
            border-radius: 50%;
            position: absolute;
        }

        /* Face 1 */
        .face-1 .dot { top: 50%; left: 50%; transform: translate(-50%, -50%); }

        /* Face 2 */
        .face-2 .dot:nth-child(1) { top: 25%; left: 25%; }
        .face-2 .dot:nth-child(2) { bottom: 25%; right: 25%; }

        /* Face 3 */
        .face-3 .dot:nth-child(1) { top: 25%; left: 25%; }
        .face-3 .dot:nth-child(2) { top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .face-3 .dot:nth-child(3) { bottom: 25%; right: 25%; }

        /* Face 4 */
        .face-4 .dot:nth-child(1) { top: 25%; left: 25%; }
        .face-4 .dot:nth-child(2) { top: 25%; right: 25%; }
        .face-4 .dot:nth-child(3) { bottom: 25%; left: 25%; }
        .face-4 .dot:nth-child(4) { bottom: 25%; right: 25%; }

        /* Face 5 */
        .face-5 .dot:nth-child(1) { top: 25%; left: 25%; }
        .face-5 .dot:nth-child(2) { top: 25%; right: 25%; }
        .face-5 .dot:nth-child(3) { top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .face-5 .dot:nth-child(4) { bottom: 25%; left: 25%; }
        .face-5 .dot:nth-child(5) { bottom: 25%; right: 25%; }

        /* Face 6 */
        .face-6 .dot:nth-child(1) { top: 25%; left: 25%; }
        .face-6 .dot:nth-child(2) { top: 25%; left: 50%; transform: translateX(-50%); }
        .face-6 .dot:nth-child(3) { top: 25%; right: 25%; }
        .face-6 .dot:nth-child(4) { bottom: 25%; left: 25%; }
        .face-6 .dot:nth-child(5) { bottom: 25%; left: 50%; transform: translateX(-50%); }
        .face-6 .dot:nth-child(6) { bottom: 25%; right: 25%; }

        .results {
            margin-top: 2rem;
            font-size: 1.3rem;
            font-weight: bold;
        }

        .hit-results, .wound-results {
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .final-result {
            margin-top: 2rem;
            font-size: 2rem;
            color: #f39c12;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">        
        <div class="input-section">
            <div class="input-row">
            <div class="input-group">
                <label for="numDice">Number of Dice</label>
                <div class="numeric-selector">
                    <div class="button-column">
                        <button class="numeric-button" data-value="-1">-1</button>
                        <button class="numeric-button" data-value="-5">-5</button>
                        <button class="numeric-button" data-value="-10">-10</button>
                    </div>
                    <div class="numeric-display" id="numericDisplay">6</div>
                    <div class="button-column">
                        <button class="numeric-button" data-value="+1">+1</button>
                        <button class="numeric-button" data-value="+5">+5</button>
                        <button class="numeric-button" data-value="+10">+10</button>
                    </div>
                </div>
                <input type="hidden" id="numDice" value="6">
            </div>
            </div>
                        <div class="input-row">
                <div class="reroll-section">
                    <div class="checkbox-container">
                        <input type="radio" id="rerollOnes" name="rerollType" value="ones">
                        <label for="rerollOnes">Reroll 1s</label>
                    </div>
                    <div class="checkbox-container">
                        <input type="radio" id="rerollHits" name="rerollType" value="hits">
                        <label for="rerollHits">Reroll Misses</label>
                    </div>
            </div>
            <div class="input-group">
                <label for="hitValue">Hit on</label>
                <div class="value-selector" id="hitSelector">
                    <div class="value-row top">
                        <div class="value-square" data-value="2">2</div>
                        <div class="value-square" data-value="3">3</div>
                    </div>
                    <div class="value-row bottom">
                        <div class="value-square" data-value="4">4</div>
                        <div class="value-square" data-value="5">5</div>
                        <div class="value-square selected" data-value="6">6</div>
                    </div>
                    </div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="sustained" name="sustained">
                        <label for="sustained">Sustained</label>
                    </div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="lethal" name="lethal">
                        <label for="lethal">Lethal</label>
                </div>
                <input type="hidden" id="hitValue" value="6">
            </div>
            <div class="input-group">
                <label for="woundValue">Wound on</label>
                <div class="value-selector" id="woundSelector">
                    <div class="value-row top">
                        <div class="value-square" data-value="2">2</div>
                        <div class="value-square" data-value="3">3</div>
                    </div>
                    <div class="value-row bottom">
                        <div class="value-square" data-value="4">4</div>
                        <div class="value-square selected" data-value="5">5</div>
                        <div class="value-square" data-value="6">6</div>
                    </div>
                </div>
                    <div class="secondary-selector" id="secondaryWoundSelector">
                        <div class="secondary-square" data-value="2">2</div>
                        <div class="secondary-square" data-value="3">3</div>
                        <div class="secondary-square" data-value="4">4</div>
                        <div class="secondary-square" data-value="5">5</div>
                        <div class="secondary-square" data-value="6">6</div>
                </div>
                <input type="hidden" id="woundValue" value="5">
                    <input type="hidden" id="secondaryWoundValue" value="">
                </div>
                <div class="reroll-section">
                    <div class="checkbox-container">
                        <input type="radio" id="rerollWoundOnes" name="rerollWoundType" value="ones">
                        <label for="rerollWoundOnes">Reroll 1s</label>
                    </div>
                    <div class="checkbox-container">
                        <input type="radio" id="rerollWoundHits" name="rerollWoundType" value="hits">
                        <label for="rerollWoundHits">Reroll Misses</label>
                    </div>
                </div>
            </div>
        </div>

        <button class="roll-button" id="rollButton">Roll for Attack!</button>
        
        <div class="phase-indicator" id="phaseIndicator"></div>
        
        <div class="dice-container" id="diceContainer"></div>
    </div>

    <script>
        const rollButton = document.getElementById('rollButton');
        const diceContainer = document.getElementById('diceContainer');
        const phaseIndicator = document.getElementById('phaseIndicator');
        const results = document.getElementById('results');
        const numDiceInput = document.getElementById('numDice');
        const hitValueInput = document.getElementById('hitValue');
        const woundValueInput = document.getElementById('woundValue');

        let dice = [];
        let hitResults = [];
        let woundResults = [];
        let lethalHits = [];
        let isRolling = false;

        function createDice() {
            const numDice = parseInt(numDiceInput.value);
            
            // Only clear and recreate if the number of dice has actually changed
            if (dice.length !== numDice) {
                // Clear both the array AND the DOM container
                dice = [];
                diceContainer.innerHTML = '';
                
                for (let i = 0; i < numDice; i++) {
                    const diceWrapper = document.createElement('div');
                    diceWrapper.className = 'dice-wrapper';
                    
                    const diceElement = document.createElement('div');
                    diceElement.className = 'dice';
                    diceElement.id = `dice-${i}`;
                    
                    // Create all 6 faces
                    for (let face = 1; face <= 6; face++) {
                        const faceElement = document.createElement('div');
                        faceElement.className = `face face-${face}`;
                        
                        // Add dots based on face number
                        for (let dot = 0; dot < face; dot++) {
                            const dotElement = document.createElement('div');
                            dotElement.className = 'dot';
                            faceElement.appendChild(dotElement);
                        }
                        
                        diceElement.appendChild(faceElement);
                    }
                    
                    diceWrapper.appendChild(diceElement);
                    diceContainer.appendChild(diceWrapper);
                    dice.push(diceElement);
                }
            }
        }

        function rollSingleDice(diceElement) {
            return new Promise((resolve) => {
                diceElement.classList.add('rolling');
                
                const randomNumber = Math.floor(Math.random() * 6) + 1;

                setTimeout(() => {
                    diceElement.classList.remove('rolling');
                    diceElement.style.transform = 'rotateX(0deg) rotateY(0deg)';
                    
                    // Clear all faces and show only the correct face
                    const faces = diceElement.querySelectorAll('.face');
                    faces.forEach((face, index) => {
                        if (index + 1 === randomNumber) {
                            face.style.display = 'flex';
                            face.style.opacity = '1';
                        } else {
                            face.style.display = 'none';
                        }
                    });
                    
                    resolve(randomNumber);
                }, 200);
            });
        }

        async function rollForHits() {
            phaseIndicator.textContent = '🎯 Rolling for Hits...';
            
            const hitPromises = dice.map(diceElement => rollSingleDice(diceElement));
            hitResults = await Promise.all(hitPromises);
            
            const hitValue = parseInt(hitValueInput.value);
            const sustainedCheckbox = document.getElementById('sustained');
            const lethalCheckbox = document.getElementById('lethal');
            const rerollOnesRadio = document.getElementById('rerollOnes');
            const rerollHitsRadio = document.getElementById('rerollHits');
            const isSustained = sustainedCheckbox.checked;
            const isLethal = lethalCheckbox.checked;
            const rerollOnes = rerollOnesRadio.checked;
            const rerollMisses = rerollHitsRadio.checked;
            
            // Handle rerolls
            if (rerollOnes || rerollMisses) {
                const rerollIndices = [];
                hitResults.forEach((result, index) => {
                    if ((rerollOnes && result === 1) || 
                        (rerollMisses && result < hitValue)) {
                        rerollIndices.push(index);
                    }
                });
                
                if (rerollIndices.length > 0) {
                    phaseIndicator.textContent = '🎯 Rerolling...';
                    
                    // Add visual indicator for dice being rerolled
                    rerollIndices.forEach(index => {
                        dice[index].style.border = '3px solid #3498db';
                    });
                    
                    // Wait a moment before rerolling
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    const rerollPromises = rerollIndices.map(index => rollSingleDice(dice[index]));
                    const rerollResults = await Promise.all(rerollPromises);
                    
                    // Update results with rerolls
                    rerollIndices.forEach((originalIndex, rerollIndex) => {
                        hitResults[originalIndex] = rerollResults[rerollIndex];
                        // Remove reroll border
                        dice[originalIndex].style.border = '';
                    });
                    
                    phaseIndicator.textContent = '🎯 Processing Hits...';
                }
            }
            
            // Track lethal hits (6s that automatically wound)
            lethalHits = [];
            if (isLethal) {
                hitResults.forEach((result, index) => {
                    if (result === 6) {
                        lethalHits.push(index);
                    }
                });
            }
            
            let hits = hitResults.filter(result => result >= hitValue);
            let hitCount = hits.length;
            let sustainedHitsCount = 0;
            
            // Check for sustained hits (6s generate additional hits)
            if (isSustained) {
                sustainedHitsCount = hitResults.filter(result => result === 6).length;
                
                // If we have sustained hits, add more dice to the pool
                if (sustainedHitsCount > 0) {
                    // Create additional dice for sustained hits
                    const additionalDice = [];
                    for (let i = 0; i < sustainedHitsCount; i++) {
                        const diceWrapper = document.createElement('div');
                        diceWrapper.className = 'dice-wrapper';
                        
                        const diceElement = document.createElement('div');
                        diceElement.className = 'dice';
                        diceElement.id = `sustained-dice-${i}`;
                        diceElement.style.border = '2px solid #f39c12'; // Mark as sustained dice
                        
                        // Create all 6 faces
                        for (let face = 1; face <= 6; face++) {
                            const faceElement = document.createElement('div');
                            faceElement.className = `face face-${face}`;
                            
                            // Add dots based on face number
                            for (let dot = 0; dot < face; dot++) {
                                const dotElement = document.createElement('div');
                                dotElement.className = 'dot';
                                faceElement.appendChild(dotElement);
                            }
                            
                            diceElement.appendChild(faceElement);
                        }
                        
                        diceWrapper.appendChild(diceElement);
                        diceContainer.appendChild(diceWrapper);
                        additionalDice.push(diceElement);
                    }
                    
                    // Sustained hits automatically count as hits (no roll needed)
                    // Show them as regular dice but don't animate them
                    additionalDice.forEach(diceElement => {
                        // Show a random face (just for visual appeal, doesn't affect gameplay)
                        const randomFace = Math.floor(Math.random() * 6) + 1;
                        const faces = diceElement.querySelectorAll('.face');
                        faces.forEach((face, index) => {
                            if (index + 1 === randomFace) {
                                face.style.display = 'flex';
                                face.style.opacity = '1';
                            } else {
                                face.style.display = 'none';
                            }
                        });
                    });
                    
                    // Sustained hits automatically count as hits (value doesn't matter, they all hit)
                    const sustainedResults = new Array(sustainedHitsCount).fill(6); // Mark all as 6s for consistency
                    hitCount += sustainedHitsCount; // Add sustained hits to total hit count
                    
                    // Track lethal hits from sustained dice (if sustained dice roll 6s and lethal is active)
                    // Since sustained hits are automatic, they don't get lethal benefits
                    
                    // Update hitResults to include sustained results
                    hitResults = hitResults.concat(sustainedResults);
                    
                    // Update dice array to include sustained dice
                    dice = dice.concat(additionalDice);
                }
            }
            
            // Mark failed hits (dice should never disappear, only fade out)
            const originalDiceCount = dice.length - sustainedHitsCount;
            hitResults.slice(0, originalDiceCount).forEach((result, index) => {
                if (result < hitValue) {
                    dice[index].classList.add('failed_hit');
                }
            });
            
            return hitCount;
        }

        async function rollForWounds(hitCount) {
            if (hitCount === 0) return { totalWounds: 0, devastatingWounds: 0 };        
            
            // Get indices of dice that hit
            const hitIndices = hitResults.map((result, index) => 
                result >= parseInt(hitValueInput.value) ? index : -1
            ).filter(index => index !== -1);
            
            // Separate lethal hits from normal hits
            const lethalHitIndices = hitIndices.filter(index => lethalHits.includes(index));
            const normalHitIndices = hitIndices.filter(index => !lethalHits.includes(index));
            
            // Lethal hits automatically wound (no roll needed)
            let automaticWounds = lethalHitIndices.length;
            
            // Mark lethal dice with a special visual indicator
            lethalHitIndices.forEach(index => {
                dice[index].style.boxShadow = '0 0 10px #f39c12';
            });
            
            // Only roll dice that hit but are not lethal
            let woundResults = [];
            let normalWounds = 0;
            let devastatingWounds = 0;
            
            if (normalHitIndices.length > 0) {
                const normalHitDice = normalHitIndices.map(index => dice[index]);
                const woundPromises = normalHitDice.map(diceElement => rollSingleDice(diceElement));
                woundResults = await Promise.all(woundPromises);
                
                const woundValue = parseInt(woundValueInput.value);
                const rerollWoundOnesRadio = document.getElementById('rerollWoundOnes');
                const rerollWoundHitsRadio = document.getElementById('rerollWoundHits');
                const rerollWoundOnes = rerollWoundOnesRadio.checked;
                const rerollWoundMisses = rerollWoundHitsRadio.checked;
                
                // Handle wound rerolls
                if (rerollWoundOnes || rerollWoundMisses) {
                    const rerollIndices = [];
                    woundResults.forEach((result, woundIndex) => {
                        if ((rerollWoundOnes && result === 1) || 
                            (rerollWoundMisses && result < woundValue)) {
                            rerollIndices.push(woundIndex);
                        }
                    });
                    
                    if (rerollIndices.length > 0) {
                        phaseIndicator.textContent = '⚔️ Rerolling Wounds...';
                        
                        // Add visual indicator for dice being rerolled
                        rerollIndices.forEach(woundIndex => {
                            const diceIndex = normalHitIndices[woundIndex];
                            dice[diceIndex].style.border = '3px solid #3498db';
                        });
                        
                        // Wait a moment before rerolling
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        const rerollPromises = rerollIndices.map(woundIndex => 
                            rollSingleDice(dice[normalHitIndices[woundIndex]])
                        );
                        const rerollResults = await Promise.all(rerollPromises);
                        
                        // Update results with rerolls
                        rerollIndices.forEach((woundIndex, rerollIndex) => {
                            woundResults[woundIndex] = rerollResults[rerollIndex];
                            const diceIndex = normalHitIndices[woundIndex];
                            // Remove reroll border
                            dice[diceIndex].style.border = '';
                        });
                        
                        phaseIndicator.textContent = '⚔️ Processing Wounds...';
                    }
                }
                
                const secondaryWoundValueInput = document.getElementById('secondaryWoundValue');
                const devastatingValue = secondaryWoundValueInput.value ? parseInt(secondaryWoundValueInput.value) : null;
                
                // Process wound results
            woundResults.forEach((result, woundIndex) => {
                    const diceIndex = normalHitIndices[woundIndex];
                    
                    if (result >= woundValue) {
                        // This is a successful wound
                        normalWounds++;
                        
                        // Check if it's also a devastating wound
                        if (devastatingValue && result >= devastatingValue) {
                            devastatingWounds++;
                            // Mark devastating wounds with purple glow
                            dice[diceIndex].style.boxShadow = '0 0 10px #9b59b6';
                        }
                    } else {
                        // Failed wound
                    dice[diceIndex].classList.add('failed_wound');
                }
            });
            }
            
            const totalWounds = automaticWounds + normalWounds;
            return { totalWounds, devastatingWounds };
        }

        async function performAttack() {
            if (isRolling) return;
            
            isRolling = true;
            rollButton.disabled = true;
            
            // Create or update dice as needed
            createDice();
            
            // Reset existing dice (never remove them from DOM)
            dice.forEach(diceElement => {
                diceElement.classList.remove('failed_hit');
                diceElement.classList.remove('failed_wound');
                diceElement.style.transform = '';
                diceElement.style.border = '';
                diceElement.style.boxShadow = '';
                
                // Restore all faces
                const faces = diceElement.querySelectorAll('.face');
                faces.forEach(face => {
                    face.style.display = '';
                    face.style.opacity = '';
                });
            });
            
            // Reset lethal hits tracking
            lethalHits = [];
            
            // Roll for hits
            const hitCount = await rollForHits();

            phaseIndicator.textContent = '🎯 ' + hitCount + ' hits';
            
            // Wait before wound phase
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Roll for wounds
            const woundResults = await rollForWounds(hitCount);

            // Display wound results with devastating wounds if applicable
            if (woundResults.devastatingWounds > 0) {
                phaseIndicator.textContent = `⚔️ ${woundResults.totalWounds} wounds (${woundResults.devastatingWounds} devastating)`;
            } else {
                phaseIndicator.textContent = `⚔️ ${woundResults.totalWounds} wounds`;
            }
                                    
            isRolling = false;
            rollButton.disabled = false;
        }

        // Handle value square selection
        function setupValueSelectors() {
            const hitSelector = document.getElementById('hitSelector');
            const woundSelector = document.getElementById('woundSelector');
            const secondaryWoundSelector = document.getElementById('secondaryWoundSelector');
            const hitValueInput = document.getElementById('hitValue');
            const woundValueInput = document.getElementById('woundValue');
            const secondaryWoundValueInput = document.getElementById('secondaryWoundValue');

            // Hit selector
            hitSelector.addEventListener('click', (e) => {
                if (e.target.classList.contains('value-square')) {
                    // Remove selected class from all squares
                    hitSelector.querySelectorAll('.value-square').forEach(square => {
                        square.classList.remove('selected');
                    });
                    // Add selected class to clicked square
                    e.target.classList.add('selected');
                    // Update hidden input
                    hitValueInput.value = e.target.dataset.value;
                }
            });

            // Wound selector
            woundSelector.addEventListener('click', (e) => {
                if (e.target.classList.contains('value-square')) {
                    // Remove selected class from all squares
                    woundSelector.querySelectorAll('.value-square').forEach(square => {
                        square.classList.remove('selected');
                    });
                    // Add selected class to clicked square
                    e.target.classList.add('selected');
                    // Update hidden input
                    woundValueInput.value = e.target.dataset.value;
                }
            });

            // Secondary wound selector
            secondaryWoundSelector.addEventListener('click', (e) => {
                if (e.target.classList.contains('secondary-square')) {
                    // Check if the clicked square is already selected
                    if (e.target.classList.contains('selected')) {
                        // Deselect the currently selected square
                        e.target.classList.remove('selected');
                        // Clear the hidden input to indicate no selection
                        secondaryWoundValueInput.value = '';
                    } else {
                        // Remove selected class from all squares
                        secondaryWoundSelector.querySelectorAll('.secondary-square').forEach(square => {
                            square.classList.remove('selected');
                        });
                        // Add selected class to clicked square
                        e.target.classList.add('selected');
                        // Update hidden input
                        secondaryWoundValueInput.value = e.target.dataset.value;
                    }
                }
            });
        }

        // Handle numeric selector
        function setupNumericSelector() {
            const numericDisplay = document.getElementById('numericDisplay');
            const numDiceInput = document.getElementById('numDice');
            const buttons = document.querySelectorAll('.numeric-button');

            function updateValue(newValue) {
                if (newValue >= 0 && newValue <= 50) {
                    numericDisplay.textContent = newValue;
                    numDiceInput.value = newValue;
                }
            }

            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    const currentValue = parseInt(numDiceInput.value);
                    const change = parseInt(button.dataset.value);
                    const newValue = currentValue + change;
                    updateValue(newValue);
                });
            });
        }

        rollButton.addEventListener('click', performAttack);
        
        // Initialize dice on page load
        createDice();
        setupValueSelectors();
        setupNumericSelector();
    </script>
</body>
</html>
